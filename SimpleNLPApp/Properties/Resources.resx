<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="HelpGeneral" xml:space="preserve">
    <value>ОБЩИЕ СВЕДЕНИЯ

Это приложение предназначено для классификации текстов с помощью моделей машинного обучения.

Оно позволяет:
- добавлять тексты и размечать их по классам;
- обучать модель на этих данных;
- выполнять автоматическую классификацию новых текстов;
- оценивать точность предсказаний по стандартным метрикам.

Интерфейс адаптирован для пользователей без глубоких знаний в ML.
</value>
  </data>
  <data name="HelpModelLogistic" xml:space="preserve">
    <value>ЛОГИСТИЧЕСКАЯ РЕГРЕССИЯ

Логистическая регрессия — это линейный классификатор, который оценивает вероятность принадлежности текста к одному из классов. Она широко применяется в задачах бинарной и многоклассовой классификации.

**Как работает**:
- Использует взвешенную сумму признаков (слов) и применяет логистическую функцию (сигмоиду), чтобы получить вероятность.
- На выходе — вероятность принадлежности к каждому классу.

**Преимущества**:
- Быстрая, надёжная и интерпретируемая.
- Позволяет понять важность признаков.
- Хорошо работает при линейной разделимости данных.

**Недостатки**:
- Сложнее интерпретировать в многоклассовом случае.
- Не справляется с сильно нелинейными границами классов.

🔹 **Параметры в интерфейсе**:
- **Learning rate** — скорость обучения. Слишком высокая может привести к скачкам, слишком низкая — к медленному обучению.
- **Epochs** — количество проходов по данным. Обычно чем больше, тем лучше, но слишком много — риск переобучения.
</value>
  </data>
  <data name="HelpModel" xml:space="preserve">
    <value>РАБОТА С МОДЕЛЯМИ

В приложении поддерживаются несколько моделей машинного обучения для классификации текстов:

1. **Наивный байесовский классификатор**
2. **Логистическая регрессия**
3. **Метод опорных векторов (SVM)**

Каждая модель имеет свои особенности, преимущества и ограничения. Выбор подходящей модели зависит от объёма данных, структуры текста и требуемой точности.

При создании новой модели вы можете выбрать желаемый алгоритм. После загрузки текстов и назначения классов вы можете запустить обучение (меню **Тренировать модель**), после чего модель будет готова к классификации новых текстов.</value>
  </data>
  <data name="HelpModelNaiveBayes" xml:space="preserve">
    <value>НАИВНЫЙ БАЙЕСОВСКИЙ КЛАССИФИКАТОР

Наивный байесовский классификатор — это вероятностная модель, которая делает предсказания на основе формулы Байеса. "Наивный" он потому, что предполагает независимость всех признаков (слов) между собой, что в реальности не всегда так, но работает достаточно хорошо.

 **Как работает**:
- Рассчитывает вероятность принадлежности текста к каждому классу на основе частоты слов в обучающей выборке.
- Выбирает класс с наибольшей вероятностью.

 **Преимущества**:
- Очень быстрый и простой в реализации.
- Хорошо работает на малых объёмах данных.
- Не склонен к переобучению.

 **Недостатки**:
- Модель "наивная": считает все слова независимыми.
- Может давать ошибочные предсказания, если ключевые признаки отсутствуют в обучении.

🔹 **Параметры в интерфейсе**:
- **Alpha** — параметр сглаживания (Лапласа), чтобы избежать деления на 0 и обнуления вероятностей.
</value>
  </data>
  <data name="HelpModelSVM" xml:space="preserve">
    <value>МЕТОД ОПОРНЫХ ВЕКТОРОВ (SVM)

SVM — это мощный алгоритм, который ищет гиперплоскость, максимально разделяющую классы в пространстве признаков. Он особенно эффективен при работе с текстами, где число признаков (слов) может быть очень большим.

**Как работает**:
- Строит границу между классами с максимальным "отступом".
- При необходимости использует ядровые функции (в данной реализации используется линейная версия).

**Преимущества**:
- Высокая точность на сложных задачах.
- Хорошо работает при большом количестве признаков.
- Более устойчив к переобучению.

**Недостатки**:
- Медленное обучение на больших объёмах данных.
- Требует настройки параметров.

**Параметры в интерфейсе**:
- **Learning rate** — шаг обновления весов.
- **Lambda** — коэффициент регуляризации, помогает бороться с переобучением.
- **Max iterations** — максимальное число итераций обучения.

SVM подходит, если:
- У вас много данных;
- Требуется высокая точность;
- Вы готовы подождать дольше ради лучшего результата.
</value>
  </data>
  <data name="HelpTextAdd" xml:space="preserve">
    <value>ДОБАВЛЕНИЕ ТЕКСТОВ

Вы можете добавить текстовые файлы через меню:
**Текст → Добавить текстовый файл**

Формат файлов — `.txt`. Один файл = один текст. Название файла будет использоваться как заголовок текста.

Если вы добавляете файл, который уже есть в системе, он будет загружен заново, но может перезаписать старый.

Также можно использовать пункт:
**Добавить текст без обработки**, если вы не хотите применять лемматизацию или стемминг к этому тексту.
</value>
  </data>
  <data name="HelpTextPreprocess" xml:space="preserve">
    <value>ПРЕДОБРАБОТКА ТЕКСТОВ

Предобработка — это автоматическая очистка текста перед обучением:

- удаление пунктуации;
- перевод в нижний регистр;
- лемматизация (или стемминг) — приведение слов к начальной форме;
- фильтрация лишних символов.

Вы можете:
- применить предобработку ко всем текстам (через меню),
- отключить её для отдельного текста через контекстное меню.

Тексты, уже предобработанные, помечаются флажком внутри системы и не будут обработаны повторно.</value>
  </data>
  <data name="HelpTextClass" xml:space="preserve">
    <value>НАЗНАЧЕНИЕ КЛАССОВ

Каждому тексту необходимо присвоить класс (категорию), чтобы использовать его для обучения модели.

Класс указывается:
- при загрузке текста;
- вручную через контекстное меню;
- или через выпадающий список в нижней части интерфейса.

Если текст не размечен — он не будет использован в обучении.

Вы можете создавать и удалять классы в меню **Класс → Добавить / Удалить**.</value>
  </data>
  <data name="HelpTextContext" xml:space="preserve">
    <value>КОНТЕКСТНОЕ МЕНЮ

При нажатии правой кнопкой мыши на текст в списке откроется контекстное меню с возможностями:

- **Изменить класс** — выбрать другой класс.
- **Удалить текст** — удалить текст из проекта.
- **Добавить/удалить предобработку** — изменить состояние обработки для этого текста.

Контекстное меню упрощает управление текстами и ускоряет работу с разметкой.
</value>
  </data>
  <data name="HelpTextMultiSelect" xml:space="preserve">
    <value>МНОЖЕСТВЕННЫЙ ВЫБОР

Вы можете выделить сразу несколько текстов.

Это полезно, если вы хотите:
- массово удалить тексты,
- изменить их класс,
- включить или выключить предобработку сразу для группы.

Команды применяются ко всем выбранным строкам.
</value>
  </data>
  <data name="HelpText" xml:space="preserve">
    <value>РАБОТА С ТЕКСТАМИ

Этот раздел посвящён загрузке, разметке и обработке текстов перед обучением модели. Вы узнаете, как добавлять текстовые файлы, присваивать им классы, применять предобработку и использовать контекстное меню для удобной работы.

Также вы научитесь работать с множественным выбором текстов, чтобы ускорить массовые действия.
</value>
  </data>
  <data name="HelpClassification" xml:space="preserve">
    <value>КЛАССИФИКАЦИЯ

Классификация — это процесс автоматического определения класса (категории) для новых текстов на основе ранее обученной модели.

Вы можете выбрать один или несколько файлов, провести их анализ и получить вероятности для каждого класса, а также финальный результат предсказания.

Система поддерживает:
- пакетную классификацию нескольких текстов;
- сравнение реальных и предсказанных классов;
- расчёт метрик качества (accuracy, precision, recall, F1);
- экспорт результатов классификации в файл.
</value>
  </data>
  <data name="HelpClassifyStart" xml:space="preserve">
    <value>ЗАПУСК КЛАССИФИКАЦИИ

Для запуска классификации сначала необходимо загрузить тексты, которые вы хотите классифицировать.

1. Нажмите пункт меню «Добавить тексты».
2. Выберите один или несколько .txt файлов.
3. Загруженные тексты появятся на экране в виде карточек.

После этого нажмите «Классифицировать». Модель предскажет класс для каждого текста, а также рассчитает вероятности принадлежности к другим возможным классам.
</value>
  </data>
  <data name="HelpClassifyLabels" xml:space="preserve">
    <value>РЕАЛЬНЫЕ И ПРЕДСКАЗАННЫЕ КЛАССЫ

У каждого текста можно задать реальный класс вручную через выпадающий список «Реальный класс».

Если вы хотите задать один и тот же класс сразу нескольким текстам:
- выделите их с помощью клавиш Ctrl или Shift;
- воспользуйтесь пунктом меню «Назначить класс выбранным» и выберите нужный класс.

После запуска классификации в каждой карточке отобразится предсказанный класс. Под ним отображаются вероятности принадлежности текста ко всем доступным классам.
</value>
  </data>
  <data name="HelpClassifyMetrics" xml:space="preserve">
    <value>ОЦЕНКА КАЧЕСТВА (МЕТРИКИ)

После запуска классификации, если у всех текстов указаны реальные классы, программа автоматически рассчитает метрики оценки качества модели:

• Accuracy — точность (доля правильных предсказаний).
• Precision — насколько предсказания модели надёжны по одному классу.
• Recall — насколько полно модель охватывает нужный класс.
• F1-score — среднее значение между Precision и Recall.

Метрики отображаются в правой части окна, в специальной панели.
</value>
  </data>
  <data name="HelpClassifyExport" xml:space="preserve">
    <value>ЭКСПОРТ МЕТРИК

Если вы хотите сохранить текущие результаты классификации, нажмите «Экспорт метрик» в верхнем меню.

Будет создан файл с расширением .snlpmetrics. В нём содержатся значения Accuracy, Precision, Recall и F1-score.

Этот файл можно использовать для отчётов, анализа качества модели или ведения истории экспериментов.
</value>
  </data>
  <data name="HelpModelTraining" xml:space="preserve">
    <value>ОБУЧЕНИЕ МОДЕЛИ

После загрузки текстов и назначения им классов вы можете запустить процесс обучения модели — это ключевой шаг, на основе которого будет происходить вся дальнейшая классификация.

Шаги:

1. Убедитесь, что все тексты размечены (присвоены классы).
2. Убедитесь, что выбран метод предобработки (лемматизация или стемминг).
3. Перейдите в меню:
   **Тренировать модель**

Процесс обучения отображается через прогресс-бар, включающий:
- предобработку текстов (если включена);
- векторизацию (TF-IDF);
- собственно обучение модели.

По завершении:
- модель становится готовой к использованию;
- справа отображаются её параметры;
- при выборе Наивного Байеса дополнительно показываются топ-5 признаков для каждого класса.

Ошибки:
- Если не выбраны тексты или отсутствуют классы, обучение не начнётся.
- Если модель уже обучена, она будет перезаписана при следующем запуске.
</value>
  </data>
  <data name="HelpInterface" xml:space="preserve">
    <value>ИНТЕРФЕЙС И УПРАВЛЕНИЕ

В этом разделе описан пользовательский интерфейс приложения. Вы узнаете:

- как устроено главное окно и где начать работу;
- как создавать, загружать и управлять моделью;
- как осуществляется предобработка текстов;
- как работает окно модели и список текстов;
- как использовать верхнее меню и контекстные действия.

Раздел подскажет, где искать нужные функции, как ориентироваться в интерфейсе и что делать на каждом этапе работы.</value>
  </data>
  <data name="HelpUIStart" xml:space="preserve">
    <value>ГЛАВНОЕ МЕНЮ

После запуска приложения вы видите стартовое окно с тремя кнопками:

1. **Новая модель** — открывает окно создания модели.
2. **Загрузить модель** — позволяет выбрать ранее сохранённую модель из файла `.snlp`.
3. **Подготовить тексты** — запускает процесс предобработки текстовых файлов.

В правом нижнем углу находится кнопка **«?»**, открывающая справку.

Выбор одного из пунктов переводит вас в соответствующее рабочее окно.</value>
  </data>
  <data name="HelpUICreate" xml:space="preserve">
    <value>СОЗДАНИЕ МОДЕЛИ

Окно создания модели содержит:

- поле для ввода имени модели;
- выпадающий список для выбора типа модели (например, логистическая регрессия, наивный байес и др.);
- параметры, специфичные для выбранного типа модели (например, learning rate, epochs и др.);
- кнопки **Назад** (возврат в главное меню) и **Создать** (открывает окно модели).

Обратите внимание: параметры, заданные на этом этапе, **нельзя изменить после создания**.
</value>
  </data>
  <data name="HelpUILoad" xml:space="preserve">
    <value>ЗАГРУЗКА МОДЕЛИ

Кнопка **Загрузить модель** в главном меню открывает диалог выбора файла `.snlp` — это формат сохранённой модели, включая обученные параметры и векторизатор.

После выбора файла:
- открывается окно модели;
- отображаются все тексты, классы и параметры;
- вы можете приступить к классификации или дообучению.

Если файл повреждён или несовместим, приложение выдаст соответствующее сообщение об ошибке.</value>
  </data>
  <data name="HelpUIPrepare" xml:space="preserve">
    <value>ПРЕДОБРАБОТКА ТЕКСТОВ

Окно предобработки открывается из главного меню по кнопке **«Подготовить тексты»**.

Возможности:
- выбрать путь, куда сохранить обработанные тексты;
- выбрать метод приведения к одной форме (лемматизация или стемминг);
- добавить `.txt` файлы для обработки;
- просмотреть список выбранных файлов;
- удалить выделенные тексты через контекстное меню;
- нажать **Подготовить тексты** для запуска обработки.

После завершения предобработки окно автоматически закроется.</value>
  </data>
  <data name="HelpUIMain" xml:space="preserve">
    <value>ОКНО МОДЕЛИ

Это основное рабочее окно приложения после создания или загрузки модели.

### В нижней части:
- список загруженных текстов (`ListBox`);
- чекбокс **«Выбрать все»** — выделяет/снимает все тексты.

### В верхней части:
- текущая модель: тип и параметры;
- метод приведения к одной форме;
- фильтрация текстов по классам (выпадающий список).

Тексты можно добавлять через верхнее меню. Контекстное меню доступно по правому клику на тексте.

Параметры модели отображаются справа (например, learning rate, epochs и т.д.).</value>
  </data>
  <data name="HelpUIContext" xml:space="preserve">
    <value>КОНТЕКСТНОЕ МЕНЮ ТЕКСТОВ

По правому клику на тексте в списке открывается контекстное меню с функциями:

- **Изменить класс** — присвоить тексту нужную категорию.
- **Удалить текст** — удалить выбранные элементы.
- **Добавить/удалить предобработку** — включить или отключить повторную обработку текста.

Это удобно при работе с множеством файлов, особенно при ручной разметке.</value>
  </data>
  <data name="HelpUIMenu" xml:space="preserve">
    <value>ВЕРХНЕЕ МЕНЮ

Главное окно содержит меню с вкладками:

**Файл**
- Новая модель
- Открыть модель
- Закрыть модель
- Выгрузить модель

**Класс**
- Добавить класс
- Удалить класс

**Текст**
- Добавить текст
- Добавить без обработки
- Подготовить тексты

**Тренировать модель**
- Запускает процесс обучения (если все условия соблюдены)

**Тест**
- Классификация текста (открывает окно классификации)

**Сеть**
- Загрузить новости с сайта interfax.ru

**Справка**
- Открывает окно справочной информации

Меню обеспечивает полный доступ ко всем функциям приложения и доступно из любого рабочего состояния.
</value>
  </data>
  <data name="HelpModelKNN" xml:space="preserve">
    <value>KNN (k-ближайших соседей)

Алгоритм KNN (k-nearest neighbors) классифицирует текст, опираясь на ближайшие тексты в обучающей выборке. Он не обучается напрямую, а просто запоминает вектора всех тренировочных текстов и их классы. При классификации нового текста он ищет k ближайших соседей и определяет итоговый класс голосованием.

Как работает:
- вычисляется расстояние между входным текстом и каждым обучающим текстом (используется косинусное расстояние);
- выбираются `k` ближайших по расстоянию текстов;
- итоговый класс — это тот, что встречается чаще всего среди этих `k` текстов.

Преимущества:
- Простота реализации;
- Нет фазы обучения — только сохранение данных;
- Подходит для небольших и средних наборов данных;
- Можно легко адаптировать под новые данные (просто добавить вектора).

🔹 Недостатки:
- При большом количестве текстов становится медленным;
- Чувствителен к масштабу и размерности данных;
- Требует хранения всей обучающей выборки.

🔹 Параметры:
- **K** — число соседей, которые учитываются при классификации. Значение по умолчанию — 3.
  Рекомендуемый диапазон: **1–15**.
  Малые значения чувствительны к шуму, большие — могут сглаживать результат.

🔹 Пример:
Если k = 3, и среди ближайших соседей 2 текста класса "Политика" и 1 текст класса "Экономика", то новый текст будет отнесён к классу "Политика".

---

⚠️ При выборе модели KNN на этапе создания, необходимо указать значение `k`. Оно отображается в окне параметров модели и фиксируется на момент создания. После этого изменить его невозможно.
</value>
  </data>
  <data name="HelpDecisionTree" xml:space="preserve">
    <value>Справка: Decision Tree (Дерево решений)

Дерево решений — это понятный и логичный алгоритм классификации, который принимает решения путём последовательных разбиений данных на основе признаков.

В каждом узле дерева происходит проверка условия вида:
Признак[i] ≤ Порог

Если условие выполняется — переходим в левое поддерево, иначе — в правое. Это продолжается до тех пор, пока не достигнут лист, в котором уже задан предсказанный класс.

Параметры модели:
• MaxDepth — максимальная глубина дерева. Чем выше значение, тем сложнее и точнее дерево, но тем выше риск переобучения.
• Ограничение глубины позволяет контролировать обобщающую способность модели.

🧩 Особенности:
• Простая интерпретация и наглядная структура.
• Хорошо работает даже на небольших объёмах данных.
• Может переобучаться при слишком глубоком дереве (если MaxDepth не задан).

✅ Когда использовать:
• Когда важна интерпретируемость модели.
• Для быстрого прототипирования.
• При наличии немногочисленных, но информативных признаков.
</value>
  </data>
  <data name="HelpModelExport" xml:space="preserve">
    <value>Выгрузка модели

После того как модель была обучена, её можно сохранить для дальнейшего использования. Для этого в верхнем меню выберите пункт «Файл» → «Выгрузить модель».

Модель будет сохранена в файл с расширением .snlp. Этот файл содержит:
• Тип модели (например, NaiveBayes, LogisticRegression и т.д.);
• Все параметры модели (например, альфа, скорость обучения, глубина дерева и т.д.);
• Список классов;
• Обученные данные (веса, вероятности, дерево, и т.д.);
• Информацию о том, была ли модель обучена.

Файл можно затем загрузить обратно через пункт «Открыть модель» и продолжить работу с ней: классифицировать тексты, экспортировать метрики или просто проанализировать результат.

Важно: если модель не была обучена, выгруженный файл может быть неполным. Убедитесь, что обучение выполнено перед сохранением.
</value>
  </data>
</root>